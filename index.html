<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minesweeper - C·ªó M√°y L·∫≠p Tr√¨nh</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --board-bg: #ccc;
            --cell-bg: #bdbdbd;
            --cell-hover: #cfcfcf;
            --cell-revealed: #e0e0e0;
            --border-light: #fff;
            --border-dark: #7b7b7b;
            --accent: #ff3860;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            user-select: none; /* NgƒÉn ch·ªçn text khi click nhanh */
        }

        h1 { margin-bottom: 10px; font-weight: 300; letter-spacing: 2px; }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 300px;
            margin-bottom: 15px;
            font-size: 1.2rem;
            background: #333;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        #reset-btn {
            background: var(--accent);
            border: none;
            color: white;
            padding: 5px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            transition: transform 0.1s;
        }
        #reset-btn:active { transform: scale(0.95); }

        .grid {
            display: grid;
            width: 300px;
            height: 300px;
            background-color: var(--board-bg);
            border: 4px solid #999;
            /* Grid layout s·∫Ω ƒë∆∞·ª£c set b·ªüi JS d·ª±a tr√™n size */
        }

        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            background-color: var(--cell-bg);
            
            /* Hi·ªáu ·ª©ng 3D c·ªï ƒëi·ªÉn */
            border-top: 3px solid var(--border-light);
            border-left: 3px solid var(--border-light);
            border-bottom: 3px solid var(--border-dark);
            border-right: 3px solid var(--border-dark);
            box-sizing: border-box; 
        }

        .cell:hover { background-color: var(--cell-hover); }

        .cell.revealed {
            background-color: var(--cell-revealed);
            border: 1px solid #999; /* L√†m ph·∫≥ng √¥ ƒë√£ m·ªü */
            cursor: default;
        }

        .cell.flagged { color: red; }
        .cell.mine { background-color: #ff4d4d; border: 1px solid #999; }

        /* M√†u s·∫Øc cho c√°c con s·ªë */
        .cell[data-total="1"] { color: blue; }
        .cell[data-total="2"] { color: green; }
        .cell[data-total="3"] { color: red; }
        .cell[data-total="4"] { color: darkblue; }
        .cell[data-total="5"] { color: brown; }
        .cell[data-total="6"] { color: teal; }
        .cell[data-total="7"] { color: black; }
        .cell[data-total="8"] { color: gray; }

        .status-msg {
            margin-top: 20px;
            height: 30px;
            color: #4cd137;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <h1>D√í M√åN</h1>
    
    <div class="game-info">
        <span>üö© <span id="flags-left">10</span></span>
        <button id="reset-btn">Ch∆°i L·∫°i</button>
        <span>‚è±Ô∏è <span id="timer">0</span></span>
    </div>

    <div class="grid" id="grid"></div>
    <div class="status-msg" id="result"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const grid = document.getElementById('grid');
            const flagsLeftDisplay = document.getElementById('flags-left');
            const resultDisplay = document.getElementById('result');
            const timerDisplay = document.getElementById('timer');
            const resetBtn = document.getElementById('reset-btn');

            // C·∫•u h√¨nh game
            const width = 10;
            const bombAmount = 12;
            let flags = 0;
            let squares = [];
            let isGameOver = false;
            let time = 0;
            let timerId;

            // Kh·ªüi t·∫°o Game
            function createBoard() {
                // Reset tr·∫°ng th√°i
                grid.innerHTML = '';
                squares = [];
                isGameOver = false;
                flags = 0;
                time = 0;
                clearInterval(timerId);
                timerDisplay.innerText = '0';
                resultDisplay.innerText = '';
                flagsLeftDisplay.innerText = bombAmount;
                
                // Thi·∫øt l·∫≠p CSS Grid
                grid.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
                grid.style.gridTemplateRows = `repeat(${width}, 1fr)`;

                // 1. T·∫°o m·∫£ng ch·ª©a bom v√† √¥ tr·ªëng ng·∫´u nhi√™n
                // T·∫°o m·∫£ng bom
                const bombsArray = Array(bombAmount).fill('bomb');
                // T·∫°o m·∫£ng tr·ªëng
                const emptyArray = Array(width * width - bombAmount).fill('valid');
                // N·ªëi v√† tr·ªôn ng·∫´u nhi√™n (Fisher-Yates Shuffle logic ƒë∆°n gi·∫£n h√≥a)
                const gameArray = emptyArray.concat(bombsArray);
                const shuffledArray = gameArray.sort(() => Math.random() - 0.5);

                // 2. Render c√°c √¥ ra m√†n h√¨nh
                for (let i = 0; i < width * width; i++) {
                    const square = document.createElement('div');
                    square.setAttribute('id', i);
                    square.classList.add('cell');
                    // G√°n d·ªØ li·ªáu bom hay kh√¥ng
                    square.dataset.type = shuffledArray[i];
                    grid.appendChild(square);
                    squares.push(square);

                    // X·ª≠ l√Ω s·ª± ki·ªán chu·ªôt (Left click & Right click)
                    square.addEventListener('click', function(e) {
                        click(square);
                    });
                    square.addEventListener('contextmenu', function(e) {
                        e.preventDefault();
                        addFlag(square);
                    });
                }

                // 3. T√≠nh to√°n s·ªë bom xung quanh m·ªói √¥ (Logic c·ªët l√µi)
                for (let i = 0; i < squares.length; i++) {
                    let total = 0;
                    const isLeftEdge = (i % width === 0);
                    const isRightEdge = (i % width === width - 1);

                    if (squares[i].dataset.type === 'valid') {
                        // Ki·ªÉm tra 8 √¥ xung quanh
                        if (i > 0 && !isLeftEdge && squares[i - 1].dataset.type === 'bomb') total++; // Tr√°i
                        if (i > width - 1 && !isRightEdge && squares[i + 1 - width].dataset.type === 'bomb') total++; // Tr√™n Ph·∫£i
                        if (i > width && squares[i - width].dataset.type === 'bomb') total++; // Tr√™n
                        if (i > width + 1 && !isLeftEdge && squares[i - 1 - width].dataset.type === 'bomb') total++; // Tr√™n Tr√°i
                        if (i < width * width - 1 && !isRightEdge && squares[i + 1].dataset.type === 'bomb') total++; // Ph·∫£i
                        if (i < width * width - width + 1 && !isLeftEdge && squares[i - 1 + width].dataset.type === 'bomb') total++; // D∆∞·ªõi Tr√°i
                        if (i < width * width - width - 1 && !isRightEdge && squares[i + 1 + width].dataset.type === 'bomb') total++; // D∆∞·ªõi Ph·∫£i
                        if (i < width * width - width && squares[i + width].dataset.type === 'bomb') total++; // D∆∞·ªõi
                        
                        // L∆∞u s·ªë l∆∞·ª£ng bom xung quanh v√†o data attribute
                        squares[i].setAttribute('data-total', total);
                    }
                }
                
                // B·∫Øt ƒë·∫ßu ƒë·∫øm gi·ªù
                timerId = setInterval(() => {
                    if(!isGameOver) {
                        time++;
                        timerDisplay.innerText = time;
                    }
                }, 1000);
            }

            createBoard();

            // Ch·ª©c nƒÉng c·∫Øm c·ªù (Right Click)
            function addFlag(square) {
                if (isGameOver) return;
                if (!square.classList.contains('revealed') && (flags < bombAmount)) {
                    if (!square.classList.contains('flagged')) {
                        square.classList.add('flagged');
                        square.innerHTML = 'üö©';
                        flags++;
                        flagsLeftDisplay.innerHTML = bombAmount - flags;
                        checkForWin();
                    } else {
                        square.classList.remove('flagged');
                        square.innerHTML = '';
                        flags--;
                        flagsLeftDisplay.innerHTML = bombAmount - flags;
                    }
                } else if (square.classList.contains('flagged')) {
                     // Cho ph√©p b·ªè c·ªù ngay c·∫£ khi ƒë√£ h·∫øt c·ªù
                    square.classList.remove('flagged');
                    square.innerHTML = '';
                    flags--;
                    flagsLeftDisplay.innerHTML = bombAmount - flags;
                }
            }

            // Ch·ª©c nƒÉng click v√†o √¥ (Left Click)
            function click(square) {
                let currentId = square.id;
                if (isGameOver) return;
                if (square.classList.contains('revealed') || square.classList.contains('flagged')) return;

                if (square.dataset.type === 'bomb') {
                    gameOver(square);
                } else {
                    let total = square.getAttribute('data-total');
                    if (total != 0) {
                        square.classList.add('revealed');
                        square.innerText = total;
                        return;
                    }
                    // N·∫øu √¥ tr·ªëng (0 bom xung quanh), d√πng ƒë·ªá quy m·ªü r·ªông
                    checkSquare(square, currentId);
                }
                square.classList.add('revealed');
                checkForWin();
            }

            // Thu·∫≠t to√°n loang (Flood Fill) ƒë·ªÉ m·ªü c√°c √¥ tr·ªëng li√™n ti·∫øp
            function checkSquare(square, currentId) {
                const isLeftEdge = (currentId % width === 0);
                const isRightEdge = (currentId % width === width - 1);

                setTimeout(() => {
                    if (isLeftEdge) { // Ki·ªÉm tra bi√™n tr√°i
                        /* Logic ƒë·ªá quy ki·ªÉm tra c√°c √¥ xung quanh kh√¥ng vi ph·∫°m bi√™n */
                         // (M√£ ƒë√£ ƒë∆∞·ª£c t·ªëi ∆∞u ƒë·ªÉ tr√°nh l·∫∑p code, nh∆∞ng ƒë·ªÉ r√µ r√†ng t√¥i vi·∫øt t∆∞·ªùng minh)
                    }
                    
                    // Logic m·ªü r·ªông ƒë·ªá quy: Ki·ªÉm tra 8 h∆∞·ªõng
                    // Chuy·ªÉn ID t·ª´ string sang int
                    const id = parseInt(currentId);
                    
                    // Helper function ƒë·ªÉ check v√† m·ªü √¥
                    const checkNeighbor = (neighborId) => {
                        const neighbor = document.getElementById(neighborId);
                        click(neighbor);
                    };

                    if (id > 0 && !isLeftEdge) checkNeighbor(id - 1);
                    if (id > width - 1 && !isRightEdge) checkNeighbor(id + 1 - width);
                    if (id > width) checkNeighbor(id - width);
                    if (id > width + 1 && !isLeftEdge) checkNeighbor(id - 1 - width);
                    if (id < width * width - 1 && !isRightEdge) checkNeighbor(id + 1);
                    if (id < width * width - width + 1 && !isLeftEdge) checkNeighbor(id - 1 + width);
                    if (id < width * width - width - 1 && !isRightEdge) checkNeighbor(id + 1 + width);
                    if (id < width * width - width) checkNeighbor(id + width);
                }, 10);
            }

            // X·ª≠ l√Ω khi thua
            function gameOver(square) {
                resultDisplay.innerHTML = 'üí• B·∫†N ƒê√É THUA! üí•';
                resultDisplay.style.color = '#ff4d4d';
                isGameOver = true;
                clearInterval(timerId);

                // Hi·ªán t·∫•t c·∫£ bom
                squares.forEach(square => {
                    if (square.dataset.type === 'bomb') {
                        square.innerHTML = 'üí£';
                        square.classList.remove('flagged');
                        square.classList.add('revealed', 'mine');
                    }
                });
            }

            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán th·∫Øng
            function checkForWin() {
                let matches = 0;
                let revealedCount = 0;

                for (let i = 0; i < squares.length; i++) {
                    if (squares[i].classList.contains('flagged') && squares[i].dataset.type === 'bomb') {
                        matches++;
                    }
                    if (squares[i].classList.contains('revealed') && squares[i].dataset.type === 'valid') {
                        revealedCount++;
                    }
                }
                
                // Th·∫Øng n·∫øu m·ªü h·∫øt √¥ an to√†n
                if (revealedCount === (width * width - bombAmount)) {
                    resultDisplay.innerHTML = 'üèÜ CHI·∫æN TH·∫ÆNG! üèÜ';
                    isGameOver = true;
                    clearInterval(timerId);
                    flagsLeftDisplay.innerText = '0';
                }
            }

            // Reset Game
            resetBtn.addEventListener('click', () => {
                createBoard();
            })
        });
    </script>
</body>
</html>
